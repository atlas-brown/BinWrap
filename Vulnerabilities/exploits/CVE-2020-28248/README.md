This document describes using the buffer overflow [CVE-2020-28248](http://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2020-28248) to create a remote code injection attack via a specially crafted png file.

The bug is a classic integer overflow in version `v3.0.0`.

The size of the memory region to hold the decoded image data (`data_`) is calculated as `info_.height * info_.rowbytes`. 

```
.../png-img/src/PngImg.cc:70

void PngImg::InitStorage_() {
    rowPtrs_.resize(info_.height, nullptr);
    data_ = new png_byte[info_.height * info_.rowbytes];

    for(size_t i = 0; i < info_.height; ++i) {
        rowPtrs_[i] = data_ + i * info_.rowbytes;
    }
} 
```

`info_.height` and `info_.rowbytes` are 32bit so this calculation may overflow and allocate a inadequately sized region.

Data from the decoded image may then be written past the end of inadequate buffer.

The png decompressor code will use the `rowPtrs_` to reference the memory region for the start of each row. This will be important later.

Working backwards to create the exploit, libpng registers a callback function `png_ptr->error_fn` to report errors.

```
.../png-img/third_party/libpng/pngerror.c:42


#ifdef PNG_ERROR_TEXT_SUPPORTED
PNG_FUNCTION(void,PNGAPI
png_error,(png_const_structrp png_ptr, png_const_charp error_message),
   PNG_NORETURN)
{
...

   if (png_ptr != NULL && png_ptr->error_fn != NULL)
      (*(png_ptr->error_fn))(png_constcast(png_structrp,png_ptr),
          error_message);
```

If the memory region for `png_ptr` is after `data_` then image data (user data) can be written to `png_ptr->error_fn` to gain control of the execution.

`png_ptr` points to a region 1320 bytes. Begin by conditioning the heap such that two 1320 byte regions are located near each other with the higher region allocated first.

Next create an image such that `info_.height * info_.rowbytes` overflows to be 1320 (32 bit). 

`rowbytes` is dependent on the particular pixel format of the image and the width of the image. Setting the pixel type as RGBA with 8 bits per channel results in each pixel requiring 4 bytes.

Creating an RGBA image with height = 536871077 and width = 2 results in an overflow of 1320 (32bit). 

It's useful to have a small width because each row is read and written independently. A long row will can easily cause a segfault before the data is written.

The constructor heap allocates the `png_ptr` first as `PngReadStruct::pngPtr`. The allocated region is above the next 1320 memory region to be allocated.

```
.../png-img/src/PngImg.cc:45


PngImg::PngImg(const char* buf, const size_t bufLen)
    : data_(nullptr)
{
    memset(&info_, 0, sizeof(info_));
    PngReadStruct rs;
    if(rs.Valid()) {
        BufPtr bufPtr = {buf, bufLen};
        png_set_read_fn(rs.pngPtr, (png_voidp)&bufPtr, readFromBuf);
        ReadInfo_(rs);
        InitStorage_();
        png_read_image(rs.pngPtr, &rowPtrs_[0]);
    }
}

.../png-img/src/PngStructs.h:11

class PngStruct {
public:
..
protected:
    ///
    PngStruct(PngStructConstructor constructorFn, PngStructDestructor destructorFn)
        : pngPtr(constructorFn(PNG_LIBPNG_VER_STRING, NULL, NULL, NULL))
```

The constructor then calls ```InitStorage_()``` misallocating `data_` as 1320 bytes. 
```
.../png-img/src/PngImg.cc:70

void PngImg::InitStorage_() {
    rowPtrs_.resize(info_.height, nullptr);
    data_ = new png_byte[info_.height * info_.rowbytes];

    for(size_t i = 0; i < info_.height; ++i) {
        rowPtrs_[i] = data_ + i * info_.rowbytes;
    }
} 
```

The conditioned heap places `data_` immediately before the `rs.pngPtr` memory region.

`rowPtr[0]` points the `data_` and `rowPtr[1]` points to `rs.pngPtr`.

Luckily the large `height` value does not cause a segfault!

Another bit of luck is the `png_struct` places the `error_fn` at the start of the structure so we only need to overwrite the beginning to gain control.

```
struct png_struct_def
{
#ifdef PNG_SETJMP_SUPPORTED
   jmp_buf jmp_buf_local;     /* New name in 1.6.0 for jmp_buf in png_struct */
   png_longjmp_ptr longjmp_fn;/* setjmp non-local goto function. */
   jmp_buf *jmp_buf_ptr;      /* passed to longjmp_fn */
   size_t jmp_buf_size;       /* size of the above, if allocated */
#endif
   png_error_ptr error_fn;    /* function for printing errors and aborting */
```

After allocating the memory for the decoded data, `InitStorage_()` calls  `png_read_image` to decompress the image into `data_`:

```
        png_read_image(rs.pngPtr, &rowPtrs_[0]);
```


`png_read_image` decodes each row, using the start of row pointers, `rowPtrs`, set up in `InitStorage_`

```
.../png-img/third_party/libpng/pngread.c:689

png_read_image(png_structrp png_ptr, png_bytepp image)
{
...
   image_height=png_ptr->height;

   for (j = 0; j < pass; j++)
   {
      rp = image; # passed in as &rowPtrs_[0]
      for (i = 0; i < image_height; i++)
      {
         png_read_row(png_ptr, *rp, NULL);
         rp++;
      }
   }
```

The first row is decoded into the misallocated buffer and the second row is decoded into the `rs.pngPtr` memory region. 

This callstacks show the trace to the memcpy copying the decoded bytes into the allocated region.

```
0  in __memmove_avx_unaligned_erms of ../sysdeps/x86_64/multiarch/memmove-vec-unaligned-erms.S:315
1  in png_combine_row of ../third_party/libpng/pngrutil.c:3472
2  in png_read_row of ../third_party/libpng/pngread.c:596
3  in png_read_image of ../third_party/libpng/pngread.c:742
4  in PngImg::PngImg of ../src/PngImg.cc:45
```

The second row writes its bytes into the `rs.pngPtr` memory region.

Bytes from the image go directly onto the `rs.pngPtr` region eventually overwriting `png_ptr->error_fn` with the address of `system`.

The image does not contain enough data, causing an error

```
1  in png_read_IDAT_data of ../third_party/libpng/pngrutil.c:3966

            if (png_ptr->chunk_name != png_IDAT)
               png_error(png_ptr, "Not enough image data");
```

`png_error` calls the `png_ptr->error_fn` whose destination is now `system`.


```
.../png-img/third_party/libpng/pngerror.c:42


#ifdef PNG_ERROR_TEXT_SUPPORTED
PNG_FUNCTION(void,PNGAPI
png_error,(png_const_structrp png_ptr, png_const_charp error_message),
   PNG_NORETURN)
{
...

   if (png_ptr != NULL && png_ptr->error_fn != NULL)
      (*(png_ptr->error_fn))(png_constcast(png_structrp,png_ptr),
          error_message);
```


Here is the callstack after `png_ptr->error_fn` has been called with the address of `system`.

```
0  in __libc_system of ../sysdeps/posix/system.c:198
1  in png_error of ../third_party/libpng/pngerror.c:83
2  in png_read_IDAT_data of ../third_party/libpng/pngrutil.c:3966
3  in png_read_row of ../third_party/libpng/pngread.c:533
4  in png_read_image of ../third_party/libpng/pngread.c:742
5  in PngImg::PngImg of ../src/PngImg.cc:45
```

The first argument to `system`, `png_structrp,png_ptr`, is the `rs.pngPtr` which we already overwriting to modify `png_ptr->error_fn`.

The desired command is placed in the image data at the appropiate location and written into `rs.pngPtr`. The command is now the argument to `system`. 

Now loading the image causes `system` to be executed with an arbitrary command.

Much of this exploit was created using a cyclic and gdb. 

Create a png image with a cyclic for the image data. Load that image and examine the resulting segfault.

Match the bytes in `png_ptr->error_fn` to the bytes in the image data, then replace those bytes with the address to `system`.

Similarly match the bytes in the argument to `system` to the image data, replace those bytes with the command string.

Then there is a bunch of work to figure out how the heap should look and to get it into the needed state.




